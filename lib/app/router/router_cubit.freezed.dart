// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'router_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RouterStateTearOff {
  const _$RouterStateTearOff();

  RouterStateFirstPage firstPage() {
    return const RouterStateFirstPage();
  }

  RouterStateSecondPage secondPage() {
    return const RouterStateSecondPage();
  }
}

/// @nodoc
const $RouterState = _$RouterStateTearOff();

/// @nodoc
mixin _$RouterState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() firstPage,
    required TResult Function() secondPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? firstPage,
    TResult Function()? secondPage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouterStateFirstPage value) firstPage,
    required TResult Function(RouterStateSecondPage value) secondPage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouterStateFirstPage value)? firstPage,
    TResult Function(RouterStateSecondPage value)? secondPage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RouterStateCopyWith<$Res> {
  factory $RouterStateCopyWith(
          RouterState value, $Res Function(RouterState) then) =
      _$RouterStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$RouterStateCopyWithImpl<$Res> implements $RouterStateCopyWith<$Res> {
  _$RouterStateCopyWithImpl(this._value, this._then);

  final RouterState _value;
  // ignore: unused_field
  final $Res Function(RouterState) _then;
}

/// @nodoc
abstract class $RouterStateFirstPageCopyWith<$Res> {
  factory $RouterStateFirstPageCopyWith(RouterStateFirstPage value,
          $Res Function(RouterStateFirstPage) then) =
      _$RouterStateFirstPageCopyWithImpl<$Res>;
}

/// @nodoc
class _$RouterStateFirstPageCopyWithImpl<$Res>
    extends _$RouterStateCopyWithImpl<$Res>
    implements $RouterStateFirstPageCopyWith<$Res> {
  _$RouterStateFirstPageCopyWithImpl(
      RouterStateFirstPage _value, $Res Function(RouterStateFirstPage) _then)
      : super(_value, (v) => _then(v as RouterStateFirstPage));

  @override
  RouterStateFirstPage get _value => super._value as RouterStateFirstPage;
}

/// @nodoc

class _$RouterStateFirstPage implements RouterStateFirstPage {
  const _$RouterStateFirstPage();

  @override
  String toString() {
    return 'RouterState.firstPage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is RouterStateFirstPage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() firstPage,
    required TResult Function() secondPage,
  }) {
    return firstPage();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? firstPage,
    TResult Function()? secondPage,
    required TResult orElse(),
  }) {
    if (firstPage != null) {
      return firstPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouterStateFirstPage value) firstPage,
    required TResult Function(RouterStateSecondPage value) secondPage,
  }) {
    return firstPage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouterStateFirstPage value)? firstPage,
    TResult Function(RouterStateSecondPage value)? secondPage,
    required TResult orElse(),
  }) {
    if (firstPage != null) {
      return firstPage(this);
    }
    return orElse();
  }
}

abstract class RouterStateFirstPage implements RouterState {
  const factory RouterStateFirstPage() = _$RouterStateFirstPage;
}

/// @nodoc
abstract class $RouterStateSecondPageCopyWith<$Res> {
  factory $RouterStateSecondPageCopyWith(RouterStateSecondPage value,
          $Res Function(RouterStateSecondPage) then) =
      _$RouterStateSecondPageCopyWithImpl<$Res>;
}

/// @nodoc
class _$RouterStateSecondPageCopyWithImpl<$Res>
    extends _$RouterStateCopyWithImpl<$Res>
    implements $RouterStateSecondPageCopyWith<$Res> {
  _$RouterStateSecondPageCopyWithImpl(
      RouterStateSecondPage _value, $Res Function(RouterStateSecondPage) _then)
      : super(_value, (v) => _then(v as RouterStateSecondPage));

  @override
  RouterStateSecondPage get _value => super._value as RouterStateSecondPage;
}

/// @nodoc

class _$RouterStateSecondPage implements RouterStateSecondPage {
  const _$RouterStateSecondPage();

  @override
  String toString() {
    return 'RouterState.secondPage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is RouterStateSecondPage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() firstPage,
    required TResult Function() secondPage,
  }) {
    return secondPage();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? firstPage,
    TResult Function()? secondPage,
    required TResult orElse(),
  }) {
    if (secondPage != null) {
      return secondPage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RouterStateFirstPage value) firstPage,
    required TResult Function(RouterStateSecondPage value) secondPage,
  }) {
    return secondPage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RouterStateFirstPage value)? firstPage,
    TResult Function(RouterStateSecondPage value)? secondPage,
    required TResult orElse(),
  }) {
    if (secondPage != null) {
      return secondPage(this);
    }
    return orElse();
  }
}

abstract class RouterStateSecondPage implements RouterState {
  const factory RouterStateSecondPage() = _$RouterStateSecondPage;
}
